## すごいHaskell たのしく学ぼうを読む

https://gitpitch.com/vikke/sugoi_haskell

---

## イントロダクション

* 純粋関数型プログラミングは違います。コンピュータに何をするかは伝えません。何であるかを伝えるのです。
* 良く言われる事だが、「関数型プログラミングでは、一度変数の値を設定すると、後でそれを別の値に変更することはできません」

---

## イントロダクション

* これも良く言われるが、「関数が参照透過性があり、副作用を持たない」
* これも良く言われるが、「参照透過性があるので、関数は遅延評価される」
* これも良く言われるが、静的型付け言語で型推論を持つ。

---

## 第1章 はじめの一歩

### haskellのreplはghci

* `:l myfunctions` か、 `:r`でscriptをリロード出来る

---

### 1.1. 関数呼び出し

* `arg1 * arg2` のように2つ引数を取る中置関数
* `foo arg1` のように引数を取る後置関数
* 関数が2引数を取る時、\`(バッククォート)を取る事により中置関数として呼び出せる。
	* div 92 10
	* ```
	92 `div` 10
	```
---

### 1.2. 赤ちゃんの最初の関数

* 関数定義
```
関数名 引数1 引数n = 処理
E.g. 
doubleUs x y = x * 2 + y * 2
```

---

* if式にはelse節が必須
```
doubleSmallNumber x = if x > 100
					then x
					else x * 2
```

---

* 関数名に'(シングルクォート)が使える。
```
E.g.
conanO'Brien = "It's a-me, Conan O'Brien!"
```
* 関数名の先頭は大文字は使えない。
* 上記関数は引数を取らないので、定義や名前と呼ぶ。

---
### 1.3. リスト入門

* リストには **同じ型**の0要素を複数格納出来る。
* リストは要素をカンマ区切りで並べて、角括弧で括ったもの。
```
let lostNumbers = [4,8,15,16,23,42]
```

---

#### 連結
```
[1,2,3,4] ++ [9,10,11,12]
"hello" ++ " " ++ "world"
['w','o'] ++ ['o','t']
```
* 文字列は文字のリストとして表わされる。
* `++` を使う時1つ目のリストの末尾まで走査して探す為、重い処理となる。

---
#### 連結

```
*Main> 'a':"bcd"
"abcd"
*Main> 1 : [2,3,4,5]
[1,2,3,4,5]
*Main>
```

* 2つ目のリストの先頭に1つめの要素を追加するのは軽い処理となる。

---
#### 連結

```
*Main> [1, 2, 3] ++ 4

<interactive>:22:1: error:
    • Non type-variable argument in the constraint: Num [a]
      (Use FlexibleContexts to permit this)
    • When checking the inferred type
        it :: forall a. (Num a, Num [a]) => [a]
```
* `[1, 2, 3]` というリストと結合するには数字のリストである必要があるので、
  `[1, 2, 3] ++ [4]` である必要がある。
* [1, 2, 3]は、`1:2:3:[]` の構文糖

---

#### リストの要素へのアクセス

```
*Main> "Steve Buscemi" !! 6
'B'
*Main> [9.4,33.2,96.2,11.2,23.25] !! 1
33.2
```
* !!演算子を使う。
* 添字は0から。

---

#### リストの中のリスト

```
*Main> let b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
*Main> b
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
*Main> b ++ [[1,1,1,1]]
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3],[1,1,1,1]]
```

---

#### リストの比較

```
*Main> [1,2,3] < [1,2,4]
True
```
* 辞書順に比較される。
* 空でないリストは空リストより常に大きいとみなされる。

---

#### さらなるリスト操作

```
*Main> let ar = [5,4,3,2,1]
*Main> head ar
5
*Main> tail ar
[4,3,2,1]
*Main> last ar
1
*Main> init ar
[5,4,3,2]
```

* head, tail, last, init

---

#### 空リスト操作 

```
*Main> head []
*** Exception: Prelude.head: empty list
```

* 空リストにheadすると怒られる。

---

#### その他のリスト操作

```
*Main> length [1, 2, 3]
3
*Main> null [1, 2, 3]
False
*Main> null []
True
```

* lengthでリストの長さを取れる
* nullで空リストチェック

---

#### その他のリスト操作

```
*Main> reverse [5,4,3,2,1]
[1,2,3,4,5]
*Main> take 3 [5,4,3,2,1]
[5,4,3]
*Main> take 5 [1,2]
[1,2]
*Main> take 0 [6,6,6]
[]
```

* takeで先頭から指定された数のリスト取得
* reverseでリストを逆にする。

---

#### その他のリスト操作

他いろいろ。全部書かない。

---

### 1.4. レンジでチン!

```
*Main> [1..10]
[1,2,3,4,5,6,7,8,9,10]
*Main> ['a'..'z']
"abcdefghijklmnopqrstuvwxyz"
*Main> ['A'..'z']
"ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz"
*Main> [2,4..20]
[2,4,6,8,10,12,14,16,18,20]
```

* 数値、文字をレンジで指定してリスト化出来る。

---

#### レンジと遅延評価

```
take 24 [13, 26..]
```
* 13, 26で無限リストを作って、その頭24個を取得。
  レンジは遅延評価で作られるので、必要になった時点で作られるので、こんな事が出来る。

---

### 1.5. リスト内包表記

```
*Main> [x*2 | x <- [1..10]]
[2,4,6,8,10,12,14,16,18,20]`
```

1. 1..10のレンジを作り、各要素をxに束縛する。
2. 束縛されたxを2倍して出力する。

---

#### リスト内包表記(フィルタ)

```
*Main> [x*2 | x <-[1..10], x*2 >= 12 ]
[12,14,16,18,20]
*Main> [x | x <- [50..100], x `mod`7 == 3]
[52,59,66,73,80,87,94]
```

* 内包表記に条件(述語とも言う)が追加出来る。
* 述語はリスト内包表記の最後に置き、他のパートとはカンマで区切る。
* 述語を使ってリストを間引く事をフィルタすると言う。

---

#### リスト内包表記(フィルタ)

```
boomBangs xs = [if x < 10 then "Boom!" else "Bang!" | x <- xs, odd x]
```
* 引数で入れたリストの奇数を、10未満の場合にBoom!, 10以上の場合にBang!と表示する。

---

#### リスト内包表記(複数のフィルタ)

```
*Main> [x | x <- [10..20], x /=13, x /= 15, x /=19]
[10,11,12,14,16,17,18,20]
```
* カンマで繋ぐ事により複数の述語を指定出来る。

---

#### リスト内包表記(リストの組み合わせ)

```
*Main> [x+y| x <- [1,2,3], y <- [10, 100, 1000 ] ]
[11,101,1001,12,102,1002,13,103,1003]
```

---

#### リスト内包表記(大文字抽出関数)

```
removeNonUppercase st = [c | c <- st, c `elem` ['A'..'Z']]
```

---

#### リスト内包表記(リストのリスト)

```
*Main> let xxs =  [[1,3,5,2,3,1,2,4,5], [1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]
*Main> [ [ x | x <- xs, even x ] | xs <- xxs]
[[2,2,4],[2,4,6,8],[2,4,2,6,2,6]]
```

---

### 1.6. タプル

* リストと似ている。違いは以下の2つ。
	* 複数の違う型を入れられる。
	* サイズが固定(あらかじめサイズがわかっている必要がある)

---

#### タプル(8/24)

* 別の型を格納出来る
* 型の違いを知っている

```
*Main> (1,3)
(1,3)
*Main> [(1, "aa"), (2.0, "b")]
[(1.0,"aa"),(2.0,"b")]

[(1, "aa"), (2.0, 3)]
エラー
```

---

#### ペア

* 要素の1番目と2番目を取り出す

```
Prelude> fst (1, "aa")
1
Prelude> snd (1, "aa")
"aa"
```

---

#### zip

* リストを2つ取り、ペアにして返す。
* リストの数が合わない場合は、長い方の余りは切り捨てれる。

```
Prelude> zip [1,2,3] ["a", "b", "c"]
[(1,"a"),(2,"b"),(3,"c")]

Prelude> zip [1,2,3,4,5] ["a", "b", "c"]
[(1,"a"),(2,"b"),(3,"c")]
```

---

#### 直角三角形を見付ける

* 3辺の長さはすべて整数
* 各辺の長さは10以下
* 周囲の長さは24に等しい

```
let rightTriangles = [(a, b, c) | c <- [1..10], a <- [1..c], b <- [1..a], a^2 + b^2 == c^2, a + b + c == 24]
rightTriangles 
[(8,6,10)]
```

---

## 型を信じろ!

### 明示的な型宣言

```
addThree x y z = x + y + z
:t addThree
addThree :: Num a => a -> a -> a -> a

addThree :: Int -> Int -> Int -> Int
addThree x y z = x + y + z
:t addThree
addThree :: Int -> Int -> Int -> Int
```

---

### 型変数

* 下記のようなa(大文字で始まる型では無い)を **型変数** と呼ぶ。
* どんな型でも取りうる。ジェネリクスにちょっと似ている。

```
:t head
head :: [a] -> a
```

---
* 型変数を用いた関数を **多相的関数** と呼ぶ
* head の型宣言は **任意の型のリストを引数に取り、その型の要素を1 つ返す** と読むことができる。

---

### 型クラス

```
*Main> :t (==)
(==) :: Eq a => a -> a -> Bool
```

* **==**は実際には **関数**
* 関数の名前が特殊文字のみからなる場合、その関数はデフォルトで中置関数
* **=>** のシンボルより前にあるのを **型クラス制約** という。
---

```
*Main> :t (==)
(==) :: Eq a => a -> a -> Bool
```

* この例の型宣言は、「等値性関数は、同じ型の任意の2 つの引数を取り、Bool を返す。引数の2 つの値の型はEq クラスのインスタンスでなければならない」と読める。


